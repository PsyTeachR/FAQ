[
["data-wrangling.html", "Topic 4 Data Wrangling 4.1 Importing data from multiple files 4.2 Detecting &quot;runs&quot; in a sequence", " Topic 4 Data Wrangling 4.1 Importing data from multiple files The following code allows you to read in a whole bunch of files from a directory datadir all at once into a big table. # &quot;\\\\.csv$&quot; = find all files ending with csv or CSV todo &lt;- tibble(filename = dir(&quot;datadir&quot;, &quot;\\\\.[Cc][Ss][Vv]$&quot;)) all_data &lt;- todo %&gt;% mutate(imported = read_csv(filename)) %&gt;% unnest(imported) If there is preprocessing you need to do on each file before reading it in, you can write your own function and call that in place of read_csv(). 4.2 Detecting &quot;runs&quot; in a sequence Let's say you have a table like below, and you want to find the start and end frames where you have a run of Z amidst a, b, c, d. Here is code that sets up this kind of situation. Don't worry if you don't understand this code; just run it to create the example data in runsdata, and have a look at that table. library(&quot;knitr&quot;) create_run_vec &lt;- function() { ## create a random string of letters with two runs c(rep(sample(letters[1:4]), sample(2:4, 4, TRUE)), rep(&quot;Z&quot;, 3), rep(sample(letters[1:4]), sample(2:4, 4, TRUE)), rep(&quot;Z&quot;, 3), rep(sample(letters[1:4], 2), sample(2:4, 2, TRUE))) } ## 5 subjects, 3 trials each runsdata &lt;- tibble( subject = rep(1:5, each = 3), trial = rep(1:3, 5), stimulus = rerun(15, create_run_vec())) %&gt;% unnest(stimulus) %&gt;% group_by(subject, trial) %&gt;% ungroup() %&gt;% select(subject, trial, stimulus) Let's say you want to find the start and stop frames where Z appears in stimulus, and do this independently for each combination of subject and trial. Here's how stimulus looks for subject 1 and trial 1. ## [1] &quot;d&quot; &quot;d&quot; &quot;d&quot; &quot;d&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;c&quot; &quot;c&quot; &quot;c&quot; &quot;c&quot; &quot;Z&quot; &quot;Z&quot; &quot;Z&quot; ## [18] &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;d&quot; &quot;d&quot; &quot;d&quot; &quot;c&quot; &quot;c&quot; &quot;c&quot; &quot;c&quot; &quot;Z&quot; &quot;Z&quot; &quot;Z&quot; &quot;a&quot; &quot;a&quot; ## [35] &quot;a&quot; &quot;c&quot; &quot;c&quot; So here you can see that the first run of Zs is from frame 15 to 17, 32 and the second is from 30 to 32. We want to write a function that processes the data for each trial and results in a table like this: ## # A tibble: 2 x 5 ## subject trial run start_frame end_frame ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 1 15 17 ## 2 1 1 2 30 32 The first thing to do is to add a logical vector to your tibble whose value is TRUE when the target value (e.g., Z) is present in the sequence, false otherwise. runsdata_tgt &lt;- runsdata %&gt;% mutate(is_target = (stimulus == &quot;Z&quot;)) runsdata_tgt ## # A tibble: 543 x 4 ## subject trial stimulus is_target ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1 1 d FALSE ## 2 1 1 d FALSE ## 3 1 1 d FALSE ## 4 1 1 d FALSE ## 5 1 1 b FALSE ## 6 1 1 b FALSE ## 7 1 1 b FALSE ## 8 1 1 a FALSE ## 9 1 1 a FALSE ## 10 1 1 a FALSE ## # … with 533 more rows We want to iterate over subjects and trials. We'll start by creating a tibble with columns is_target nested into a column called subtbl. runs_nest &lt;- runsdata_tgt %&gt;% select(-stimulus) %&gt;% # don&#39;t need it anymore nest(subtbl = c(is_target)) We want to iterate over the little subtables stored within subtbl in each row of the table, passing the table to a function that will find the runs and return another table, which we'll store in new column. Let's write a function to detect the runs. That function will need the function rle() (Run-Length Encoding) from base R. We'll run that on the logical vector we created (is_target). Before creating the function, let's see what rle() does on the values in is_target for subject 1, trial 1. s1t1 &lt;- runsdata_tgt %&gt;% filter(subject == 1L, trial == 1L) %&gt;% pull(is_target) s1t1 rle(s1t1) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [12] FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE ## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE ## [34] FALSE FALSE FALSE FALSE ## Run Length Encoding ## lengths: int [1:5] 14 3 12 3 5 ## values : logi [1:5] FALSE TRUE FALSE TRUE FALSE If that doesn't make sense, look at the help for rle() (type ?rle in the console). Now we're ready to write our function, detect_runs(). detect_runs &lt;- function(x) { if (!is.logical(x[[1]])) stop(&quot;&#39;x&#39; must be a tibble whose first column is of type &#39;logical&#39;&quot;) runs &lt;- rle(x[[1]]) run_start_fr &lt;- c(1L, cumsum(runs$lengths[-length(runs$lengths)]) + 1L) run_end_fr &lt;- run_start_fr + (runs$lengths - 1L) tgt_start &lt;- run_start_fr[runs$values] tgt_end &lt;- run_end_fr[runs$value] tibble(run = seq_along(tgt_start), start_fr = tgt_start, end_fr = tgt_end) } We can test the function on s1t1 just to make sure it works. detect_runs(tibble(lvec = s1t1)) ## # A tibble: 2 x 3 ## run start_fr end_fr ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 15 17 ## 2 2 30 32 OK, now we're ready to run the function. result &lt;- runs_nest %&gt;% mutate(runstbl = map(subtbl, detect_runs)) result ## # A tibble: 15 x 4 ## subject trial subtbl runstbl ## &lt;int&gt; &lt;int&gt; &lt;list&lt;df[,1]&gt;&gt; &lt;list&gt; ## 1 1 1 [37 × 1] &lt;tibble [2 × 3]&gt; ## 2 1 2 [32 × 1] &lt;tibble [2 × 3]&gt; ## 3 1 3 [38 × 1] &lt;tibble [2 × 3]&gt; ## 4 2 1 [38 × 1] &lt;tibble [2 × 3]&gt; ## 5 2 2 [36 × 1] &lt;tibble [2 × 3]&gt; ## 6 2 3 [39 × 1] &lt;tibble [2 × 3]&gt; ## 7 3 1 [34 × 1] &lt;tibble [2 × 3]&gt; ## 8 3 2 [34 × 1] &lt;tibble [2 × 3]&gt; ## 9 3 3 [38 × 1] &lt;tibble [2 × 3]&gt; ## 10 4 1 [32 × 1] &lt;tibble [2 × 3]&gt; ## 11 4 2 [38 × 1] &lt;tibble [2 × 3]&gt; ## 12 4 3 [41 × 1] &lt;tibble [2 × 3]&gt; ## 13 5 1 [37 × 1] &lt;tibble [2 × 3]&gt; ## 14 5 2 [36 × 1] &lt;tibble [2 × 3]&gt; ## 15 5 3 [33 × 1] &lt;tibble [2 × 3]&gt; Now we just have to unnest and we're done! result %&gt;% select(-subtbl) %&gt;% unnest(runstbl) ## # A tibble: 30 x 5 ## subject trial run start_fr end_fr ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 1 15 17 ## 2 1 1 2 30 32 ## 3 1 2 1 9 11 ## 4 1 2 2 23 25 ## 5 1 3 1 15 17 ## 6 1 3 2 29 31 ## 7 2 1 1 12 14 ## 8 2 1 2 28 30 ## 9 2 2 1 11 13 ## 10 2 2 2 27 29 ## # … with 20 more rows "]
]
